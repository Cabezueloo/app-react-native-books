/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Hello API Platform
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApiBooksGetCollection200,
  ApiBooksGetCollectionParams,
  ApiUsersGetCollection200,
  ApiUsersGetCollectionParams,
  Book,
  BookJsonld,
  LoginCheckPost200,
  LoginCheckPostBody,
  User,
  UserJsonld
} from '../model';

import { customInstance } from '../axios-instance';
import type { ErrorType, BodyType } from '../axios-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieves the collection of Book resources.
 * @summary Retrieves the collection of Book resources.
 */
export const apiBooksGetCollection = (
    params?: ApiBooksGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiBooksGetCollection200>(
      {url: `/api/books`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiBooksGetCollectionQueryKey = (params?: ApiBooksGetCollectionParams,) => {
    return [`/api/books`, ...(params ? [params]: [])] as const;
    }

    
export const getApiBooksGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBooksGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBooksGetCollection>>> = ({ signal }) => apiBooksGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiBooksGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiBooksGetCollection>>>
export type ApiBooksGetCollectionQueryError = ErrorType<unknown>


export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiBooksGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiBooksGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiBooksGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of Book resources.
 */

export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiBooksGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a Book resource.
 * @summary Creates a Book resource.
 */
export const apiBooksPost = (
    bookJsonld: BodyType<NonReadonly<BookJsonld>>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BookJsonld>(
      {url: `/api/books`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: bookJsonld, signal
    },
      options);
    }
  


export const getApiBooksPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksPost>>, TError,{data: BodyType<NonReadonly<BookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksPost>>, TError,{data: BodyType<NonReadonly<BookJsonld>>}, TContext> => {
    
const mutationKey = ['apiBooksPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksPost>>, {data: BodyType<NonReadonly<BookJsonld>>}> = (props) => {
          const {data} = props ?? {};

          return  apiBooksPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksPost>>>
    export type ApiBooksPostMutationBody = BodyType<NonReadonly<BookJsonld>>
    export type ApiBooksPostMutationError = ErrorType<void>

    /**
 * @summary Creates a Book resource.
 */
export const useApiBooksPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksPost>>, TError,{data: BodyType<NonReadonly<BookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksPost>>,
        TError,
        {data: BodyType<NonReadonly<BookJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiBooksPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a Book resource.
 * @summary Retrieves a Book resource.
 */
export const apiBooksIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BookJsonld>(
      {url: `/api/books/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiBooksIdGetQueryKey = (id: string,) => {
    return [`/api/books/${id}`] as const;
    }

    
export const getApiBooksIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBooksIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBooksIdGet>>> = ({ signal }) => apiBooksIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiBooksIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdGet>>>
export type ApiBooksIdGetQueryError = ErrorType<void>


export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiBooksIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiBooksIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a Book resource.
 */

export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiBooksIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the Book resource.
 * @summary Replaces the Book resource.
 */
export const apiBooksIdPut = (
    id: string,
    bookJsonld: BodyType<NonReadonly<BookJsonld>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookJsonld>(
      {url: `/api/books/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: bookJsonld
    },
      options);
    }
  


export const getApiBooksIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPut>>, TError,{id: string;data: BodyType<NonReadonly<BookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPut>>, TError,{id: string;data: BodyType<NonReadonly<BookJsonld>>}, TContext> => {
    
const mutationKey = ['apiBooksIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksIdPut>>, {id: string;data: BodyType<NonReadonly<BookJsonld>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiBooksIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdPut>>>
    export type ApiBooksIdPutMutationBody = BodyType<NonReadonly<BookJsonld>>
    export type ApiBooksIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the Book resource.
 */
export const useApiBooksIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPut>>, TError,{id: string;data: BodyType<NonReadonly<BookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksIdPut>>,
        TError,
        {id: string;data: BodyType<NonReadonly<BookJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiBooksIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the Book resource.
 * @summary Removes the Book resource.
 */
export const apiBooksIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/books/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiBooksIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiBooksIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiBooksIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdDelete>>>
    
    export type ApiBooksIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the Book resource.
 */
export const useApiBooksIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiBooksIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the Book resource.
 * @summary Updates the Book resource.
 */
export const apiBooksIdPatch = (
    id: string,
    book: BodyType<NonReadonly<Book>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookJsonld>(
      {url: `/api/books/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: book
    },
      options);
    }
  


export const getApiBooksIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<Book>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<Book>>}, TContext> => {
    
const mutationKey = ['apiBooksIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksIdPatch>>, {id: string;data: BodyType<NonReadonly<Book>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiBooksIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdPatch>>>
    export type ApiBooksIdPatchMutationBody = BodyType<NonReadonly<Book>>
    export type ApiBooksIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the Book resource.
 */
export const useApiBooksIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<Book>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksIdPatch>>,
        TError,
        {id: string;data: BodyType<NonReadonly<Book>>},
        TContext
      > => {

      const mutationOptions = getApiBooksIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Creates a user token.
 * @summary Creates a user token.
 */
export const loginCheckPost = (
    loginCheckPostBody: BodyType<LoginCheckPostBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginCheckPost200>(
      {url: `/api/login_check`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginCheckPostBody, signal
    },
      options);
    }
  


export const getLoginCheckPostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCheckPost>>, TError,{data: BodyType<LoginCheckPostBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginCheckPost>>, TError,{data: BodyType<LoginCheckPostBody>}, TContext> => {
    
const mutationKey = ['loginCheckPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginCheckPost>>, {data: BodyType<LoginCheckPostBody>}> = (props) => {
          const {data} = props ?? {};

          return  loginCheckPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginCheckPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginCheckPost>>>
    export type LoginCheckPostMutationBody = BodyType<LoginCheckPostBody>
    export type LoginCheckPostMutationError = ErrorType<unknown>

    /**
 * @summary Creates a user token.
 */
export const useLoginCheckPost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCheckPost>>, TError,{data: BodyType<LoginCheckPostBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof loginCheckPost>>,
        TError,
        {data: BodyType<LoginCheckPostBody>},
        TContext
      > => {

      const mutationOptions = getLoginCheckPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a User resource.
 * @summary Retrieves a User resource.
 */
export const me = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserJsonld>(
      {url: `/api/me`, method: 'GET', signal
    },
      options);
    }
  

export const getMeQueryKey = () => {
    return [`/api/me`] as const;
    }

    
export const getMeQueryOptions = <TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>
export type MeQueryError = ErrorType<void>


export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a User resource.
 */

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the collection of User resources.
 * @summary Retrieves the collection of User resources.
 */
export const apiUsersGetCollection = (
    params?: ApiUsersGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiUsersGetCollection200>(
      {url: `/api/users`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiUsersGetCollectionQueryKey = (params?: ApiUsersGetCollectionParams,) => {
    return [`/api/users`, ...(params ? [params]: [])] as const;
    }

    
export const getApiUsersGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersGetCollection>>> = ({ signal }) => apiUsersGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiUsersGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersGetCollection>>>
export type ApiUsersGetCollectionQueryError = ErrorType<unknown>


export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiUsersGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiUsersGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiUsersGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of User resources.
 */

export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiUsersGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a User resource.
 * @summary Creates a User resource.
 */
export const apiUsersPost = (
    userJsonld: BodyType<NonReadonly<UserJsonld>>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserJsonld>(
      {url: `/api/users`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: userJsonld, signal
    },
      options);
    }
  


export const getApiUsersPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPost>>, TError,{data: BodyType<NonReadonly<UserJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersPost>>, TError,{data: BodyType<NonReadonly<UserJsonld>>}, TContext> => {
    
const mutationKey = ['apiUsersPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersPost>>, {data: BodyType<NonReadonly<UserJsonld>>}> = (props) => {
          const {data} = props ?? {};

          return  apiUsersPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersPost>>>
    export type ApiUsersPostMutationBody = BodyType<NonReadonly<UserJsonld>>
    export type ApiUsersPostMutationError = ErrorType<void>

    /**
 * @summary Creates a User resource.
 */
export const useApiUsersPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPost>>, TError,{data: BodyType<NonReadonly<UserJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersPost>>,
        TError,
        {data: BodyType<NonReadonly<UserJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiUsersPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a User resource.
 * @summary Retrieves a User resource.
 */
export const apiUsersIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserJsonld>(
      {url: `/api/users/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiUsersIdGetQueryKey = (id: string,) => {
    return [`/api/users/${id}`] as const;
    }

    
export const getApiUsersIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersIdGet>>> = ({ signal }) => apiUsersIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiUsersIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdGet>>>
export type ApiUsersIdGetQueryError = ErrorType<void>


export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiUsersIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiUsersIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a User resource.
 */

export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiUsersIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the User resource.
 * @summary Replaces the User resource.
 */
export const apiUsersIdPut = (
    id: string,
    userJsonld: BodyType<NonReadonly<UserJsonld>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserJsonld>(
      {url: `/api/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: userJsonld
    },
      options);
    }
  


export const getApiUsersIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPut>>, TError,{id: string;data: BodyType<NonReadonly<UserJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPut>>, TError,{id: string;data: BodyType<NonReadonly<UserJsonld>>}, TContext> => {
    
const mutationKey = ['apiUsersIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersIdPut>>, {id: string;data: BodyType<NonReadonly<UserJsonld>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiUsersIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdPut>>>
    export type ApiUsersIdPutMutationBody = BodyType<NonReadonly<UserJsonld>>
    export type ApiUsersIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the User resource.
 */
export const useApiUsersIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPut>>, TError,{id: string;data: BodyType<NonReadonly<UserJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersIdPut>>,
        TError,
        {id: string;data: BodyType<NonReadonly<UserJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiUsersIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the User resource.
 * @summary Removes the User resource.
 */
export const apiUsersIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/users/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiUsersIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiUsersIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiUsersIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdDelete>>>
    
    export type ApiUsersIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the User resource.
 */
export const useApiUsersIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiUsersIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the User resource.
 * @summary Updates the User resource.
 */
export const apiUsersIdPatch = (
    id: string,
    user: BodyType<NonReadonly<User>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserJsonld>(
      {url: `/api/users/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: user
    },
      options);
    }
  


export const getApiUsersIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<User>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<User>>}, TContext> => {
    
const mutationKey = ['apiUsersIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersIdPatch>>, {id: string;data: BodyType<NonReadonly<User>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiUsersIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdPatch>>>
    export type ApiUsersIdPatchMutationBody = BodyType<NonReadonly<User>>
    export type ApiUsersIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the User resource.
 */
export const useApiUsersIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<User>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersIdPatch>>,
        TError,
        {id: string;data: BodyType<NonReadonly<User>>},
        TContext
      > => {

      const mutationOptions = getApiUsersIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
