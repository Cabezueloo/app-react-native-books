/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Hello API Platform
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApiBookTransactionsGetCollection200,
  ApiBookTransactionsGetCollectionParams,
  ApiBooksGetCollection200,
  ApiBooksGetCollectionParams,
  ApiFavoriteBooksGetCollection200,
  ApiFavoriteBooksGetCollectionParams,
  ApiMediaObjectsGetCollection200,
  ApiMediaObjectsGetCollectionParams,
  ApiMediaObjectsPostBody,
  ApiMessagesGetCollection200,
  ApiMessagesGetCollectionParams,
  ApiUsersGetCollection200,
  ApiUsersGetCollectionParams,
  BookBookWrite,
  BookJsonldBookRead,
  BookJsonldBookWrite,
  BookTransaction,
  BookTransactionJsonld,
  FavoriteBook,
  FavoriteBookJsonld,
  LoginCheckPost200,
  LoginCheckPostBody,
  MediaObjectJsonldMediaObjectRead,
  Message,
  MessageJsonld,
  UserJsonldUserRead,
  UserJsonldUserWrite,
  UserUserWrite
} from '../model';

import { customInstance } from '../axios-instance';
import type { ErrorType, BodyType } from '../axios-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieves the collection of Book resources.
 * @summary Retrieves the collection of Book resources.
 */
export const apiBooksGetCollection = (
    params?: ApiBooksGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiBooksGetCollection200>(
      {url: `/api/books`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiBooksGetCollectionQueryKey = (params?: ApiBooksGetCollectionParams,) => {
    return [`/api/books`, ...(params ? [params]: [])] as const;
    }

    
export const getApiBooksGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBooksGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBooksGetCollection>>> = ({ signal }) => apiBooksGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiBooksGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiBooksGetCollection>>>
export type ApiBooksGetCollectionQueryError = ErrorType<unknown>


export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiBooksGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiBooksGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiBooksGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of Book resources.
 */

export function useApiBooksGetCollection<TData = Awaited<ReturnType<typeof apiBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiBooksGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a Book resource.
 * @summary Creates a Book resource.
 */
export const apiBooksPost = (
    bookJsonldBookWrite: BodyType<BookJsonldBookWrite>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BookJsonldBookRead>(
      {url: `/api/books`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: bookJsonldBookWrite, signal
    },
      options);
    }
  


export const getApiBooksPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksPost>>, TError,{data: BodyType<BookJsonldBookWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksPost>>, TError,{data: BodyType<BookJsonldBookWrite>}, TContext> => {
    
const mutationKey = ['apiBooksPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksPost>>, {data: BodyType<BookJsonldBookWrite>}> = (props) => {
          const {data} = props ?? {};

          return  apiBooksPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksPost>>>
    export type ApiBooksPostMutationBody = BodyType<BookJsonldBookWrite>
    export type ApiBooksPostMutationError = ErrorType<void>

    /**
 * @summary Creates a Book resource.
 */
export const useApiBooksPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksPost>>, TError,{data: BodyType<BookJsonldBookWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksPost>>,
        TError,
        {data: BodyType<BookJsonldBookWrite>},
        TContext
      > => {

      const mutationOptions = getApiBooksPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a Book resource.
 * @summary Retrieves a Book resource.
 */
export const apiBooksIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BookJsonldBookRead>(
      {url: `/api/books/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiBooksIdGetQueryKey = (id: string,) => {
    return [`/api/books/${id}`] as const;
    }

    
export const getApiBooksIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBooksIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBooksIdGet>>> = ({ signal }) => apiBooksIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiBooksIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdGet>>>
export type ApiBooksIdGetQueryError = ErrorType<void>


export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiBooksIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBooksIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiBooksIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a Book resource.
 */

export function useApiBooksIdGet<TData = Awaited<ReturnType<typeof apiBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiBooksIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the Book resource.
 * @summary Replaces the Book resource.
 */
export const apiBooksIdPut = (
    id: string,
    bookJsonldBookWrite: BodyType<BookJsonldBookWrite>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookJsonldBookRead>(
      {url: `/api/books/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: bookJsonldBookWrite
    },
      options);
    }
  


export const getApiBooksIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPut>>, TError,{id: string;data: BodyType<BookJsonldBookWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPut>>, TError,{id: string;data: BodyType<BookJsonldBookWrite>}, TContext> => {
    
const mutationKey = ['apiBooksIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksIdPut>>, {id: string;data: BodyType<BookJsonldBookWrite>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiBooksIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdPut>>>
    export type ApiBooksIdPutMutationBody = BodyType<BookJsonldBookWrite>
    export type ApiBooksIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the Book resource.
 */
export const useApiBooksIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPut>>, TError,{id: string;data: BodyType<BookJsonldBookWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksIdPut>>,
        TError,
        {id: string;data: BodyType<BookJsonldBookWrite>},
        TContext
      > => {

      const mutationOptions = getApiBooksIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the Book resource.
 * @summary Removes the Book resource.
 */
export const apiBooksIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/books/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiBooksIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiBooksIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiBooksIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdDelete>>>
    
    export type ApiBooksIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the Book resource.
 */
export const useApiBooksIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiBooksIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the Book resource.
 * @summary Updates the Book resource.
 */
export const apiBooksIdPatch = (
    id: string,
    bookBookWrite: BodyType<BookBookWrite>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookJsonldBookRead>(
      {url: `/api/books/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: bookBookWrite
    },
      options);
    }
  


export const getApiBooksIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPatch>>, TError,{id: string;data: BodyType<BookBookWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPatch>>, TError,{id: string;data: BodyType<BookBookWrite>}, TContext> => {
    
const mutationKey = ['apiBooksIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBooksIdPatch>>, {id: string;data: BodyType<BookBookWrite>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiBooksIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBooksIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiBooksIdPatch>>>
    export type ApiBooksIdPatchMutationBody = BodyType<BookBookWrite>
    export type ApiBooksIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the Book resource.
 */
export const useApiBooksIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBooksIdPatch>>, TError,{id: string;data: BodyType<BookBookWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBooksIdPatch>>,
        TError,
        {id: string;data: BodyType<BookBookWrite>},
        TContext
      > => {

      const mutationOptions = getApiBooksIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves the collection of BookTransaction resources.
 * @summary Retrieves the collection of BookTransaction resources.
 */
export const apiBookTransactionsGetCollection = (
    params?: ApiBookTransactionsGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiBookTransactionsGetCollection200>(
      {url: `/api/book_transactions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiBookTransactionsGetCollectionQueryKey = (params?: ApiBookTransactionsGetCollectionParams,) => {
    return [`/api/book_transactions`, ...(params ? [params]: [])] as const;
    }

    
export const getApiBookTransactionsGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError = ErrorType<unknown>>(params?: ApiBookTransactionsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBookTransactionsGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>> = ({ signal }) => apiBookTransactionsGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiBookTransactionsGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>>
export type ApiBookTransactionsGetCollectionQueryError = ErrorType<unknown>


export function useApiBookTransactionsGetCollection<TData = Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiBookTransactionsGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBookTransactionsGetCollection<TData = Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBookTransactionsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBookTransactionsGetCollection<TData = Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBookTransactionsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of BookTransaction resources.
 */

export function useApiBookTransactionsGetCollection<TData = Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiBookTransactionsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiBookTransactionsGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a BookTransaction resource.
 * @summary Creates a BookTransaction resource.
 */
export const apiBookTransactionsPost = (
    bookTransactionJsonld: BodyType<NonReadonly<BookTransactionJsonld>>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BookTransactionJsonld>(
      {url: `/api/book_transactions`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: bookTransactionJsonld, signal
    },
      options);
    }
  


export const getApiBookTransactionsPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsPost>>, TError,{data: BodyType<NonReadonly<BookTransactionJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsPost>>, TError,{data: BodyType<NonReadonly<BookTransactionJsonld>>}, TContext> => {
    
const mutationKey = ['apiBookTransactionsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBookTransactionsPost>>, {data: BodyType<NonReadonly<BookTransactionJsonld>>}> = (props) => {
          const {data} = props ?? {};

          return  apiBookTransactionsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBookTransactionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiBookTransactionsPost>>>
    export type ApiBookTransactionsPostMutationBody = BodyType<NonReadonly<BookTransactionJsonld>>
    export type ApiBookTransactionsPostMutationError = ErrorType<void>

    /**
 * @summary Creates a BookTransaction resource.
 */
export const useApiBookTransactionsPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsPost>>, TError,{data: BodyType<NonReadonly<BookTransactionJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBookTransactionsPost>>,
        TError,
        {data: BodyType<NonReadonly<BookTransactionJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiBookTransactionsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a BookTransaction resource.
 * @summary Retrieves a BookTransaction resource.
 */
export const apiBookTransactionsIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BookTransactionJsonld>(
      {url: `/api/book_transactions/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiBookTransactionsIdGetQueryKey = (id: string,) => {
    return [`/api/book_transactions/${id}`] as const;
    }

    
export const getApiBookTransactionsIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiBookTransactionsIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>> = ({ signal }) => apiBookTransactionsIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiBookTransactionsIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>>
export type ApiBookTransactionsIdGetQueryError = ErrorType<void>


export function useApiBookTransactionsIdGet<TData = Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBookTransactionsIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiBookTransactionsIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBookTransactionsIdGet<TData = Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiBookTransactionsIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiBookTransactionsIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiBookTransactionsIdGet<TData = Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a BookTransaction resource.
 */

export function useApiBookTransactionsIdGet<TData = Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiBookTransactionsIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiBookTransactionsIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the BookTransaction resource.
 * @summary Replaces the BookTransaction resource.
 */
export const apiBookTransactionsIdPut = (
    id: string,
    bookTransactionJsonld: BodyType<NonReadonly<BookTransactionJsonld>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookTransactionJsonld>(
      {url: `/api/book_transactions/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: bookTransactionJsonld
    },
      options);
    }
  


export const getApiBookTransactionsIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdPut>>, TError,{id: string;data: BodyType<NonReadonly<BookTransactionJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdPut>>, TError,{id: string;data: BodyType<NonReadonly<BookTransactionJsonld>>}, TContext> => {
    
const mutationKey = ['apiBookTransactionsIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBookTransactionsIdPut>>, {id: string;data: BodyType<NonReadonly<BookTransactionJsonld>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiBookTransactionsIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBookTransactionsIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiBookTransactionsIdPut>>>
    export type ApiBookTransactionsIdPutMutationBody = BodyType<NonReadonly<BookTransactionJsonld>>
    export type ApiBookTransactionsIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the BookTransaction resource.
 */
export const useApiBookTransactionsIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdPut>>, TError,{id: string;data: BodyType<NonReadonly<BookTransactionJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBookTransactionsIdPut>>,
        TError,
        {id: string;data: BodyType<NonReadonly<BookTransactionJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiBookTransactionsIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the BookTransaction resource.
 * @summary Removes the BookTransaction resource.
 */
export const apiBookTransactionsIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/book_transactions/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiBookTransactionsIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiBookTransactionsIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBookTransactionsIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiBookTransactionsIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBookTransactionsIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiBookTransactionsIdDelete>>>
    
    export type ApiBookTransactionsIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the BookTransaction resource.
 */
export const useApiBookTransactionsIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBookTransactionsIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiBookTransactionsIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the BookTransaction resource.
 * @summary Updates the BookTransaction resource.
 */
export const apiBookTransactionsIdPatch = (
    id: string,
    bookTransaction: BodyType<NonReadonly<BookTransaction>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookTransactionJsonld>(
      {url: `/api/book_transactions/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: bookTransaction
    },
      options);
    }
  


export const getApiBookTransactionsIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<BookTransaction>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<BookTransaction>>}, TContext> => {
    
const mutationKey = ['apiBookTransactionsIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiBookTransactionsIdPatch>>, {id: string;data: BodyType<NonReadonly<BookTransaction>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiBookTransactionsIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiBookTransactionsIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiBookTransactionsIdPatch>>>
    export type ApiBookTransactionsIdPatchMutationBody = BodyType<NonReadonly<BookTransaction>>
    export type ApiBookTransactionsIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the BookTransaction resource.
 */
export const useApiBookTransactionsIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiBookTransactionsIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<BookTransaction>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiBookTransactionsIdPatch>>,
        TError,
        {id: string;data: BodyType<NonReadonly<BookTransaction>>},
        TContext
      > => {

      const mutationOptions = getApiBookTransactionsIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves the collection of FavoriteBook resources.
 * @summary Retrieves the collection of FavoriteBook resources.
 */
export const apiFavoriteBooksGetCollection = (
    params?: ApiFavoriteBooksGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiFavoriteBooksGetCollection200>(
      {url: `/api/favorite_books`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiFavoriteBooksGetCollectionQueryKey = (params?: ApiFavoriteBooksGetCollectionParams,) => {
    return [`/api/favorite_books`, ...(params ? [params]: [])] as const;
    }

    
export const getApiFavoriteBooksGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError = ErrorType<unknown>>(params?: ApiFavoriteBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiFavoriteBooksGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>> = ({ signal }) => apiFavoriteBooksGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiFavoriteBooksGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>>
export type ApiFavoriteBooksGetCollectionQueryError = ErrorType<unknown>


export function useApiFavoriteBooksGetCollection<TData = Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiFavoriteBooksGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiFavoriteBooksGetCollection<TData = Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiFavoriteBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiFavoriteBooksGetCollection<TData = Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiFavoriteBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of FavoriteBook resources.
 */

export function useApiFavoriteBooksGetCollection<TData = Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiFavoriteBooksGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiFavoriteBooksGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a FavoriteBook resource.
 * @summary Creates a FavoriteBook resource.
 */
export const apiFavoriteBooksPost = (
    favoriteBookJsonld: BodyType<NonReadonly<FavoriteBookJsonld>>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FavoriteBookJsonld>(
      {url: `/api/favorite_books`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: favoriteBookJsonld, signal
    },
      options);
    }
  


export const getApiFavoriteBooksPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksPost>>, TError,{data: BodyType<NonReadonly<FavoriteBookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksPost>>, TError,{data: BodyType<NonReadonly<FavoriteBookJsonld>>}, TContext> => {
    
const mutationKey = ['apiFavoriteBooksPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiFavoriteBooksPost>>, {data: BodyType<NonReadonly<FavoriteBookJsonld>>}> = (props) => {
          const {data} = props ?? {};

          return  apiFavoriteBooksPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiFavoriteBooksPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiFavoriteBooksPost>>>
    export type ApiFavoriteBooksPostMutationBody = BodyType<NonReadonly<FavoriteBookJsonld>>
    export type ApiFavoriteBooksPostMutationError = ErrorType<void>

    /**
 * @summary Creates a FavoriteBook resource.
 */
export const useApiFavoriteBooksPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksPost>>, TError,{data: BodyType<NonReadonly<FavoriteBookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiFavoriteBooksPost>>,
        TError,
        {data: BodyType<NonReadonly<FavoriteBookJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiFavoriteBooksPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a FavoriteBook resource.
 * @summary Retrieves a FavoriteBook resource.
 */
export const apiFavoriteBooksIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FavoriteBookJsonld>(
      {url: `/api/favorite_books/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiFavoriteBooksIdGetQueryKey = (id: string,) => {
    return [`/api/favorite_books/${id}`] as const;
    }

    
export const getApiFavoriteBooksIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiFavoriteBooksIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>> = ({ signal }) => apiFavoriteBooksIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiFavoriteBooksIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>>
export type ApiFavoriteBooksIdGetQueryError = ErrorType<void>


export function useApiFavoriteBooksIdGet<TData = Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiFavoriteBooksIdGet<TData = Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiFavoriteBooksIdGet<TData = Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a FavoriteBook resource.
 */

export function useApiFavoriteBooksIdGet<TData = Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiFavoriteBooksIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the FavoriteBook resource.
 * @summary Replaces the FavoriteBook resource.
 */
export const apiFavoriteBooksIdPut = (
    id: string,
    favoriteBookJsonld: BodyType<NonReadonly<FavoriteBookJsonld>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<FavoriteBookJsonld>(
      {url: `/api/favorite_books/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: favoriteBookJsonld
    },
      options);
    }
  


export const getApiFavoriteBooksIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdPut>>, TError,{id: string;data: BodyType<NonReadonly<FavoriteBookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdPut>>, TError,{id: string;data: BodyType<NonReadonly<FavoriteBookJsonld>>}, TContext> => {
    
const mutationKey = ['apiFavoriteBooksIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiFavoriteBooksIdPut>>, {id: string;data: BodyType<NonReadonly<FavoriteBookJsonld>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiFavoriteBooksIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiFavoriteBooksIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiFavoriteBooksIdPut>>>
    export type ApiFavoriteBooksIdPutMutationBody = BodyType<NonReadonly<FavoriteBookJsonld>>
    export type ApiFavoriteBooksIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the FavoriteBook resource.
 */
export const useApiFavoriteBooksIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdPut>>, TError,{id: string;data: BodyType<NonReadonly<FavoriteBookJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiFavoriteBooksIdPut>>,
        TError,
        {id: string;data: BodyType<NonReadonly<FavoriteBookJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiFavoriteBooksIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the FavoriteBook resource.
 * @summary Removes the FavoriteBook resource.
 */
export const apiFavoriteBooksIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/favorite_books/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiFavoriteBooksIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiFavoriteBooksIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiFavoriteBooksIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiFavoriteBooksIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiFavoriteBooksIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiFavoriteBooksIdDelete>>>
    
    export type ApiFavoriteBooksIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the FavoriteBook resource.
 */
export const useApiFavoriteBooksIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiFavoriteBooksIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiFavoriteBooksIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the FavoriteBook resource.
 * @summary Updates the FavoriteBook resource.
 */
export const apiFavoriteBooksIdPatch = (
    id: string,
    favoriteBook: BodyType<NonReadonly<FavoriteBook>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<FavoriteBookJsonld>(
      {url: `/api/favorite_books/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: favoriteBook
    },
      options);
    }
  


export const getApiFavoriteBooksIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<FavoriteBook>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<FavoriteBook>>}, TContext> => {
    
const mutationKey = ['apiFavoriteBooksIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiFavoriteBooksIdPatch>>, {id: string;data: BodyType<NonReadonly<FavoriteBook>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiFavoriteBooksIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiFavoriteBooksIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiFavoriteBooksIdPatch>>>
    export type ApiFavoriteBooksIdPatchMutationBody = BodyType<NonReadonly<FavoriteBook>>
    export type ApiFavoriteBooksIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the FavoriteBook resource.
 */
export const useApiFavoriteBooksIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiFavoriteBooksIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<FavoriteBook>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiFavoriteBooksIdPatch>>,
        TError,
        {id: string;data: BodyType<NonReadonly<FavoriteBook>>},
        TContext
      > => {

      const mutationOptions = getApiFavoriteBooksIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Creates a user token.
 * @summary Creates a user token.
 */
export const loginCheckPost = (
    loginCheckPostBody: BodyType<LoginCheckPostBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginCheckPost200>(
      {url: `/api/login_check`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginCheckPostBody, signal
    },
      options);
    }
  


export const getLoginCheckPostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCheckPost>>, TError,{data: BodyType<LoginCheckPostBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginCheckPost>>, TError,{data: BodyType<LoginCheckPostBody>}, TContext> => {
    
const mutationKey = ['loginCheckPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginCheckPost>>, {data: BodyType<LoginCheckPostBody>}> = (props) => {
          const {data} = props ?? {};

          return  loginCheckPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginCheckPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginCheckPost>>>
    export type LoginCheckPostMutationBody = BodyType<LoginCheckPostBody>
    export type LoginCheckPostMutationError = ErrorType<unknown>

    /**
 * @summary Creates a user token.
 */
export const useLoginCheckPost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCheckPost>>, TError,{data: BodyType<LoginCheckPostBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof loginCheckPost>>,
        TError,
        {data: BodyType<LoginCheckPostBody>},
        TContext
      > => {

      const mutationOptions = getLoginCheckPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves the collection of MediaObject resources.
 * @summary Retrieves the collection of MediaObject resources.
 */
export const apiMediaObjectsGetCollection = (
    params?: ApiMediaObjectsGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiMediaObjectsGetCollection200>(
      {url: `/api/media_objects`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiMediaObjectsGetCollectionQueryKey = (params?: ApiMediaObjectsGetCollectionParams,) => {
    return [`/api/media_objects`, ...(params ? [params]: [])] as const;
    }

    
export const getApiMediaObjectsGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError = ErrorType<unknown>>(params?: ApiMediaObjectsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMediaObjectsGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>> = ({ signal }) => apiMediaObjectsGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiMediaObjectsGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>>
export type ApiMediaObjectsGetCollectionQueryError = ErrorType<unknown>


export function useApiMediaObjectsGetCollection<TData = Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiMediaObjectsGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMediaObjectsGetCollection<TData = Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiMediaObjectsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMediaObjectsGetCollection<TData = Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiMediaObjectsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of MediaObject resources.
 */

export function useApiMediaObjectsGetCollection<TData = Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiMediaObjectsGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiMediaObjectsGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a MediaObject resource.
 * @summary Creates a MediaObject resource.
 */
export const apiMediaObjectsPost = (
    apiMediaObjectsPostBody?: BodyType<ApiMediaObjectsPostBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(apiMediaObjectsPostBody?.file !== undefined) {
 formData.append('file', apiMediaObjectsPostBody.file)
 }

      return customInstance<MediaObjectJsonldMediaObjectRead>(
      {url: `/api/media_objects`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getApiMediaObjectsPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMediaObjectsPost>>, TError,{data: BodyType<ApiMediaObjectsPostBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMediaObjectsPost>>, TError,{data: BodyType<ApiMediaObjectsPostBody>}, TContext> => {
    
const mutationKey = ['apiMediaObjectsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMediaObjectsPost>>, {data: BodyType<ApiMediaObjectsPostBody>}> = (props) => {
          const {data} = props ?? {};

          return  apiMediaObjectsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMediaObjectsPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiMediaObjectsPost>>>
    export type ApiMediaObjectsPostMutationBody = BodyType<ApiMediaObjectsPostBody>
    export type ApiMediaObjectsPostMutationError = ErrorType<void>

    /**
 * @summary Creates a MediaObject resource.
 */
export const useApiMediaObjectsPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMediaObjectsPost>>, TError,{data: BodyType<ApiMediaObjectsPostBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiMediaObjectsPost>>,
        TError,
        {data: BodyType<ApiMediaObjectsPostBody>},
        TContext
      > => {

      const mutationOptions = getApiMediaObjectsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a MediaObject resource.
 * @summary Retrieves a MediaObject resource.
 */
export const apiMediaObjectsIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MediaObjectJsonldMediaObjectRead>(
      {url: `/api/media_objects/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiMediaObjectsIdGetQueryKey = (id: string,) => {
    return [`/api/media_objects/${id}`] as const;
    }

    
export const getApiMediaObjectsIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMediaObjectsIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>> = ({ signal }) => apiMediaObjectsIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiMediaObjectsIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>>
export type ApiMediaObjectsIdGetQueryError = ErrorType<void>


export function useApiMediaObjectsIdGet<TData = Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMediaObjectsIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiMediaObjectsIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMediaObjectsIdGet<TData = Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMediaObjectsIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiMediaObjectsIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMediaObjectsIdGet<TData = Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a MediaObject resource.
 */

export function useApiMediaObjectsIdGet<TData = Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMediaObjectsIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiMediaObjectsIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the collection of Message resources.
 * @summary Retrieves the collection of Message resources.
 */
export const apiMessagesGetCollection = (
    params?: ApiMessagesGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiMessagesGetCollection200>(
      {url: `/api/messages`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiMessagesGetCollectionQueryKey = (params?: ApiMessagesGetCollectionParams,) => {
    return [`/api/messages`, ...(params ? [params]: [])] as const;
    }

    
export const getApiMessagesGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError = ErrorType<unknown>>(params?: ApiMessagesGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMessagesGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMessagesGetCollection>>> = ({ signal }) => apiMessagesGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiMessagesGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiMessagesGetCollection>>>
export type ApiMessagesGetCollectionQueryError = ErrorType<unknown>


export function useApiMessagesGetCollection<TData = Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiMessagesGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMessagesGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiMessagesGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMessagesGetCollection<TData = Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiMessagesGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMessagesGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiMessagesGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMessagesGetCollection<TData = Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiMessagesGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of Message resources.
 */

export function useApiMessagesGetCollection<TData = Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiMessagesGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiMessagesGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a Message resource.
 * @summary Creates a Message resource.
 */
export const apiMessagesPost = (
    messageJsonld: BodyType<NonReadonly<MessageJsonld>>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageJsonld>(
      {url: `/api/messages`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: messageJsonld, signal
    },
      options);
    }
  


export const getApiMessagesPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesPost>>, TError,{data: BodyType<NonReadonly<MessageJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMessagesPost>>, TError,{data: BodyType<NonReadonly<MessageJsonld>>}, TContext> => {
    
const mutationKey = ['apiMessagesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMessagesPost>>, {data: BodyType<NonReadonly<MessageJsonld>>}> = (props) => {
          const {data} = props ?? {};

          return  apiMessagesPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMessagesPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiMessagesPost>>>
    export type ApiMessagesPostMutationBody = BodyType<NonReadonly<MessageJsonld>>
    export type ApiMessagesPostMutationError = ErrorType<void>

    /**
 * @summary Creates a Message resource.
 */
export const useApiMessagesPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesPost>>, TError,{data: BodyType<NonReadonly<MessageJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiMessagesPost>>,
        TError,
        {data: BodyType<NonReadonly<MessageJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiMessagesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a Message resource.
 * @summary Retrieves a Message resource.
 */
export const apiMessagesIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageJsonld>(
      {url: `/api/messages/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiMessagesIdGetQueryKey = (id: string,) => {
    return [`/api/messages/${id}`] as const;
    }

    
export const getApiMessagesIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiMessagesIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMessagesIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMessagesIdGet>>> = ({ signal }) => apiMessagesIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiMessagesIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiMessagesIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiMessagesIdGet>>>
export type ApiMessagesIdGetQueryError = ErrorType<void>


export function useApiMessagesIdGet<TData = Awaited<ReturnType<typeof apiMessagesIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMessagesIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiMessagesIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMessagesIdGet<TData = Awaited<ReturnType<typeof apiMessagesIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiMessagesIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiMessagesIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiMessagesIdGet<TData = Awaited<ReturnType<typeof apiMessagesIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a Message resource.
 */

export function useApiMessagesIdGet<TData = Awaited<ReturnType<typeof apiMessagesIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiMessagesIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiMessagesIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the Message resource.
 * @summary Replaces the Message resource.
 */
export const apiMessagesIdPut = (
    id: string,
    messageJsonld: BodyType<NonReadonly<MessageJsonld>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<MessageJsonld>(
      {url: `/api/messages/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: messageJsonld
    },
      options);
    }
  


export const getApiMessagesIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdPut>>, TError,{id: string;data: BodyType<NonReadonly<MessageJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdPut>>, TError,{id: string;data: BodyType<NonReadonly<MessageJsonld>>}, TContext> => {
    
const mutationKey = ['apiMessagesIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMessagesIdPut>>, {id: string;data: BodyType<NonReadonly<MessageJsonld>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMessagesIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMessagesIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiMessagesIdPut>>>
    export type ApiMessagesIdPutMutationBody = BodyType<NonReadonly<MessageJsonld>>
    export type ApiMessagesIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the Message resource.
 */
export const useApiMessagesIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdPut>>, TError,{id: string;data: BodyType<NonReadonly<MessageJsonld>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiMessagesIdPut>>,
        TError,
        {id: string;data: BodyType<NonReadonly<MessageJsonld>>},
        TContext
      > => {

      const mutationOptions = getApiMessagesIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the Message resource.
 * @summary Removes the Message resource.
 */
export const apiMessagesIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/messages/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiMessagesIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiMessagesIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMessagesIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiMessagesIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMessagesIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiMessagesIdDelete>>>
    
    export type ApiMessagesIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the Message resource.
 */
export const useApiMessagesIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiMessagesIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiMessagesIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the Message resource.
 * @summary Updates the Message resource.
 */
export const apiMessagesIdPatch = (
    id: string,
    message: BodyType<NonReadonly<Message>>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<MessageJsonld>(
      {url: `/api/messages/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: message
    },
      options);
    }
  


export const getApiMessagesIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<Message>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<Message>>}, TContext> => {
    
const mutationKey = ['apiMessagesIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMessagesIdPatch>>, {id: string;data: BodyType<NonReadonly<Message>>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMessagesIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiMessagesIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiMessagesIdPatch>>>
    export type ApiMessagesIdPatchMutationBody = BodyType<NonReadonly<Message>>
    export type ApiMessagesIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the Message resource.
 */
export const useApiMessagesIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiMessagesIdPatch>>, TError,{id: string;data: BodyType<NonReadonly<Message>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiMessagesIdPatch>>,
        TError,
        {id: string;data: BodyType<NonReadonly<Message>>},
        TContext
      > => {

      const mutationOptions = getApiMessagesIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a User resource.
 * @summary Retrieves a User resource.
 */
export const me = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserJsonldUserRead>(
      {url: `/api/me`, method: 'GET', signal
    },
      options);
    }
  

export const getMeQueryKey = () => {
    return [`/api/me`] as const;
    }

    
export const getMeQueryOptions = <TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>
export type MeQueryError = ErrorType<void>


export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a User resource.
 */

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the collection of User resources.
 * @summary Retrieves the collection of User resources.
 */
export const apiUsersGetCollection = (
    params?: ApiUsersGetCollectionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiUsersGetCollection200>(
      {url: `/api/users`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getApiUsersGetCollectionQueryKey = (params?: ApiUsersGetCollectionParams,) => {
    return [`/api/users`, ...(params ? [params]: [])] as const;
    }

    
export const getApiUsersGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersGetCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersGetCollection>>> = ({ signal }) => apiUsersGetCollection(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiUsersGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersGetCollection>>>
export type ApiUsersGetCollectionQueryError = ErrorType<unknown>


export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params: undefined |  ApiUsersGetCollectionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiUsersGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiUsersGetCollection>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of User resources.
 */

export function useApiUsersGetCollection<TData = Awaited<ReturnType<typeof apiUsersGetCollection>>, TError = ErrorType<unknown>>(
 params?: ApiUsersGetCollectionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersGetCollection>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiUsersGetCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates a User resource.
 * @summary Creates a User resource.
 */
export const apiUsersPost = (
    userJsonldUserWrite: BodyType<UserJsonldUserWrite>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserJsonldUserRead>(
      {url: `/api/users`, method: 'POST',
      headers: {'Content-Type': 'application/ld+json', },
      data: userJsonldUserWrite, signal
    },
      options);
    }
  


export const getApiUsersPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPost>>, TError,{data: BodyType<UserJsonldUserWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersPost>>, TError,{data: BodyType<UserJsonldUserWrite>}, TContext> => {
    
const mutationKey = ['apiUsersPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersPost>>, {data: BodyType<UserJsonldUserWrite>}> = (props) => {
          const {data} = props ?? {};

          return  apiUsersPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersPost>>>
    export type ApiUsersPostMutationBody = BodyType<UserJsonldUserWrite>
    export type ApiUsersPostMutationError = ErrorType<void>

    /**
 * @summary Creates a User resource.
 */
export const useApiUsersPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersPost>>, TError,{data: BodyType<UserJsonldUserWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersPost>>,
        TError,
        {data: BodyType<UserJsonldUserWrite>},
        TContext
      > => {

      const mutationOptions = getApiUsersPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieves a User resource.
 * @summary Retrieves a User resource.
 */
export const apiUsersIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserJsonldUserRead>(
      {url: `/api/users/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getApiUsersIdGetQueryKey = (id: string,) => {
    return [`/api/users/${id}`] as const;
    }

    
export const getApiUsersIdGetQueryOptions = <TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiUsersIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiUsersIdGet>>> = ({ signal }) => apiUsersIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiUsersIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdGet>>>
export type ApiUsersIdGetQueryError = ErrorType<void>


export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiUsersIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiUsersIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiUsersIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a User resource.
 */

export function useApiUsersIdGet<TData = Awaited<ReturnType<typeof apiUsersIdGet>>, TError = ErrorType<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiUsersIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replaces the User resource.
 * @summary Replaces the User resource.
 */
export const apiUsersIdPut = (
    id: string,
    userJsonldUserWrite: BodyType<UserJsonldUserWrite>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserJsonldUserRead>(
      {url: `/api/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/ld+json', },
      data: userJsonldUserWrite
    },
      options);
    }
  


export const getApiUsersIdPutMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPut>>, TError,{id: string;data: BodyType<UserJsonldUserWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPut>>, TError,{id: string;data: BodyType<UserJsonldUserWrite>}, TContext> => {
    
const mutationKey = ['apiUsersIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersIdPut>>, {id: string;data: BodyType<UserJsonldUserWrite>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiUsersIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdPut>>>
    export type ApiUsersIdPutMutationBody = BodyType<UserJsonldUserWrite>
    export type ApiUsersIdPutMutationError = ErrorType<void>

    /**
 * @summary Replaces the User resource.
 */
export const useApiUsersIdPut = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPut>>, TError,{id: string;data: BodyType<UserJsonldUserWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersIdPut>>,
        TError,
        {id: string;data: BodyType<UserJsonldUserWrite>},
        TContext
      > => {

      const mutationOptions = getApiUsersIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Removes the User resource.
 * @summary Removes the User resource.
 */
export const apiUsersIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/users/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getApiUsersIdDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['apiUsersIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiUsersIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdDelete>>>
    
    export type ApiUsersIdDeleteMutationError = ErrorType<void>

    /**
 * @summary Removes the User resource.
 */
export const useApiUsersIdDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiUsersIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Updates the User resource.
 * @summary Updates the User resource.
 */
export const apiUsersIdPatch = (
    id: string,
    userUserWrite: BodyType<UserUserWrite>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserJsonldUserRead>(
      {url: `/api/users/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/merge-patch+json', },
      data: userUserWrite
    },
      options);
    }
  


export const getApiUsersIdPatchMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPatch>>, TError,{id: string;data: BodyType<UserUserWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPatch>>, TError,{id: string;data: BodyType<UserUserWrite>}, TContext> => {
    
const mutationKey = ['apiUsersIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiUsersIdPatch>>, {id: string;data: BodyType<UserUserWrite>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiUsersIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApiUsersIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof apiUsersIdPatch>>>
    export type ApiUsersIdPatchMutationBody = BodyType<UserUserWrite>
    export type ApiUsersIdPatchMutationError = ErrorType<void>

    /**
 * @summary Updates the User resource.
 */
export const useApiUsersIdPatch = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof apiUsersIdPatch>>, TError,{id: string;data: BodyType<UserUserWrite>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof apiUsersIdPatch>>,
        TError,
        {id: string;data: BodyType<UserUserWrite>},
        TContext
      > => {

      const mutationOptions = getApiUsersIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
